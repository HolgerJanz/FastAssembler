Fast Assembler 1.8 - Tutorial
=============================
Holger Janz, 11-11-2021


introduction
------------

This tutorial is intended to help
you quickly familiarize yourself
with the use of Fast Assembler.
Basics in 6502 assembler are
assumed.
For technical information on Fast
Assembler (e.g. for all pseudo
operations) the documentation
FA.DOC or the man pages FA.MAN
can be used.

Fast Assembler is a file to file
assembler for SpartaDOS X, i.e. the
assembler source text must be in a
file in ATASCII format and the
assembler generates an object file.

A big advantage of Fast Assembler is
that it can generate both
SpartaDOS X and Atari DOS object
files.

This tutorial briefly explains the
basics of the structure of the
source code. Afterwards, the
creation of Atari DOS programs is
dealt with with the help of a small
demo. In the last section several
examples of SpartaDOS X programs
are shown.

The following assembler files are
required for the tutorial:

Atari DOS example
- Color demonstration
  RAINBOW.ASM

SpartaDOS X examples
- Hello Atari
  HELLO.ASM
- Memory-resident program
  TSR.ASM
  TSR_CALL.ASM
- Communication between programs
  CALLER.ASM
  CALLEE.ASM
- Program to compare files
  MY_COMP.ASM

An editor for ATASCII files is
required for the tutorial. I can
recommend XEDIT from FJC for this.
This offers the possibility to open
two files at the same time, has a
very good cut-and-paste
functionality and can make spaces
visible. The editor is called with
XEDIT [name.ext], the <HELP> key
takes you to a help menu. The
SpartaDOS X Editor ED is also
suitable.

JFC (Jonathan Halliday) kindly
gave me permission to share his
editor with Fast Assembler.
Thanks again to FJC!


Structure of the FA source code
-------------------------------

The source text is line-oriented,
i.e. each line can contain a
command. There may also be blank
lines; these must not contain any
further spaces. For example, if
line 42 contains a space, the
following error message is
generated:
42:
ERROR: Unexpected eol

In XEDIT you can use the command
<CONROL> <H> to track down spaces.
<CONTROL> <H> makes the RETURN
character visible at the end of the
line, whereby spaces can be
recognized and deleted.

Comment lines begin with *.
Everything after * up to the end of
the line is ignored by the
assembler.

Example:
* This is a comment!

Comments can also follow a command.
There they do not have to be
introduced with *. The assembler
ignores all characters after a
command up to the end of the line.

A command line is structured as
follows:
[label] opcode [operand] [comment]

Example with label and comment:
start ldx # $ 08 set X register

Example without label and comment:
ldy # $ 10

A special feature compared to other
assemblers are the operations that
can be used both with the
accumulator and with addressing.
The @ sign must be used for the
accumulator.

Example ASL on address $ 3000:
        asl $ 3000

Example ASL on accumulator:
        asl @


RAINBOW.ASM - color demonstration
---------------------------------

This example shows how Atari DOS
compatible programs can be created.
It's a little demo with classic
Atari color scrolling.

Assemble with:
FA RAINBOW.ASM RAINBOE.COM

Execute with:
RAINBOW

The program is ended with START.

The program can be viewed and
edited with:
XEDIT RAINBOW.ASM
or:
ED RAINBOW.ASM

The program consists of two blocks.
One block contains the actual
program, the second the start
address. A classic Atari DOS
program. Blocks are introduced with
the pseudo command BLK. The second
parameter contains the type. DOS
stands for Atari DOS block. The
third parameter is the start address
of the block. The BLK DOS
instruction corresponds to the ORG
or *= instruction in other
assemblers.

In order to get to know the error
behavior, the instruction should
now:
      bne loop
can be changed as follows:
      bne loopX

When assembling with:
FA RAINBOW.ASM RAINBOW.COM

the following error message appears:
ERROR: Undeclared label or symbol

When the source text has been
corrected again, a space should be
inserted in the empty line 4. With
<CONTROL> <H> you can make RETURN
characters visible in XEDIT. Now you
can see that there is a space in the
line. The following error message
appears:
ERROR: Unexpected eol

After the correction, you should try
a little more and study the
wrongdoing.


HELLO.ASM - Hello Atari
-----------------------

This is an example of a SpartaDOS X
program. It cannot be run under
Atari DOS. This example uses
Relocatable Code and Symbolic Links.

Assemble with:
FA HELLO.ASM HELLO.COM

Execute with:
HELLO

After entering a name e.g. Holger,
it greets:
Hello Holger!

The SpartaDOS X symbols PRINTF and
GETS are used. These symbols are
only resolved when the program is
started. They are called with JSR and
await their parameters immediately
afterwards.

If you make a mistake, you will get
a runtime error. As an example, the
line:
PRINTF smb 'PRINTF'
can be changed as follows:
PRINTF smb 'PRINTFX'

The program can be assembled.
When starting, however, the
following error message is output:
PRINTFX symbol
154 Symbol not defined

More information about the symbols
can be found in the "SpartaDOS X
Programming Guide".

The program consists of two blocks,
a relocatable code block and a
relocatable allocate block. Both
have in common that the loading
address is not known at assembly
time. Such blocks are always
automatically loaded from MEMLO by
SpartaDOS X and MEMLO is then set
further. The addresses in the
program are then also adapted. For
the Allocate Block, SpartaDOS X only
continues to set MEMLO, i.e. the
memory is not initialized. If the
program is ended, MEMLO will be
reset by SpartaDOS X.


TSR / TSR_CALL.ASM - example
Memory-resident program
----------------------------

In SpartaDOS X it is very easy to
write memory-resident programs.
These are programs that are not
removed from memory when finished.

This can be achieved with the
INSTALL symbol. It is initialized
with 0 when a program is started.
If INTALL has the value $ FF when
the program is ended, it is not
removed from memory, i.e. MEMLO is
not reset. This makes it very easy
to write additional drivers.

You can also give your subroutines
a name and thus define new
SpartaDOS X symbols. This is done
with the following block command:
blk update new <address> '<name>'

If the name begins with @, it is
also recognized as a command in
COMMAND.

This example consists of two
programs:
1) TSR.ASM defines a new symbol
@GREET, which is also known as a
command (the name begins with @)
2) TSR_CALL.ASM uses this symbol.
For this reason it only works if
TSR has been started beforehand
and the @GREET symbol is known.
If not, the following error occurs:
@GREET symbol
154 Symbol not defined

When TSR has been carried out,
GREET can be called directly from
SpartaDOS X, or the program
TSR_CALL can be called, which calls
the symbol.


CALLER / CALLEE.ASM - example
Communication between programs
------------------------------

In SpartaDOS X you can directly
switch to another program (CALLEE)
from one program (CALLER) with the
 function U_LOAD. The FLAG symbol
 can be used to transfer a value
 to the called program. There are
 other ways of transferring data to
 the called program. To keep the
 example simple, these are not used
 here. The called program can set a
 return value with the STATUS
 symbol.

The CALLER program calls another
program and sets FLAG beforehand.
The value for FLAG and the program
name are transferred via the
command line, e.g .:
CALLER 2 CALLEE.COM

The CALLEE program reads FLAG,
multiplies the value by 8 and sets
STATUS with the result.
The MUL_32 function is used for
this. This function expects the
parameters at certain addresses
relative to COMTAB and thus also
writes the result.

Both programs output the values ​​of
FLAG and STATUS that you have set
or received.


EX5COMP.ASM - example
Program to compare files
------------------------

This example shows how a new
external command for SpartaDOS X
can be developed.
It is similar to the COMP command
and compares two files. One
difference is that the result is not
only output with PRINTF, but also
STATUS is set. If the files are not
equal then STATUS is set to $ FF
(255). Since this is a value above
$80(128), it is interpreted by
SpartaDOS X as an error. Since the
error number $FF(255) has no error
text, the following output occurs:
255 System ERROR

Setting an error number has the
advantage that you can respond to it
in a batch file with the
IF ERROR 255 command. This can be
used e.g. for automatic tests if a
program to be tested creates a file
and the expected result is already
available in another file.

